FILLIT
	-The program will read in a string of text to a BUFFER
	-The function IS_VALID will check the BUFFER to verify it is composed of valid tetriminoes.
		-If it is formatted properly after each tetrimino will be passed to a CLASSIFY function.
			-The classify function will return a type if it matches a valid tetrimino, otherwise it will return an ERROR.
			-The IS_VALID function will then create a item in a list for the corresponding type returned from CLASSIFY.
		-If it is NOT formatted properly, or CLASSIFY returns an ERROR the program will print a USAGE MESSAGE and exit.
		-If it hasn't EXITED then the INPUT can be assumed to be VALID.
	-If IS_VALID returns a list of items(tetriminoes) then the main function will pass the list to SOLVE.
	-The function SOLVE will take the item at the beginning of the list(a specific tetrimino) and attempt to place it inside a square.
		-HOW?!?!?!?!?!!?!?
		solve(list_item, square)
		- Attempt to place the item into the square. (call FIT function)
			-If it is successful//we need to save this as a potential solution
				-If there are more pieces in the list, then call solve again with the next piece.
				-If there are no more pieces in the list, return the square (it is complete.)
			-If it is not successful 
				-If there are bits to shift, then shift the bits in the char array and call solve again with the bitshifted piece.
				-If there are no bits left to shift, return an error.
		-
		-
	-SOLVE will return a char **array which will contain the alphabetized tetriminoes.
	-The main function will print the char **array including newlines, then exit.









	No longer ordered structurally: 
		SOLVE is passed a list of items. 
		Those items can contain a bitmap to represent them, or a char array, however we can represent them to solve the puzzle.
			give the structs that build them a preset bitmap in a char array 
			which can be shifted by 1 char to simulate moving the piece when recursively called EX:
			
			ITEM BITMAP: 1010\0\0\0\0\0\0\0\0\0\0  Followed by all nulls from strnew
			POTENTIAL SMALLEST SQUARE: 110000000000000000
				The first run though solve will fail because of the conflicting 1's in the first place 
				(ALL THE CONFLICTS SHOULD ONLY CHECK IF THE SQUARE IS 0 BECAUSE THEY WILL HAVE DIFFERENT VALUES(ABC))
		
			So we shift the bitmap and the ITEM BITMAP is passed as 01010\0\0\0\0\0\0\0\0\0\0
			POTENTIAL SMALLEST SQUARE: 110000000000000000

				The second run through will fail as well
			So we shift the bitmap and the ITEM BITMAP is passed as 001010\0\0\0\0\0\0\0\0\0
			POTENTIAL SMALLEST SQUARE: 110000000000000000

			Now that should succeed since there are no conflicts.
				Now that there is a potential solution, we need to call the function with the next shape(item in the list)




		char **array might be most effective.

		Since we can represent them as letters

Depending on the tetrimino, we may need to shift them different amounts.
Examples:

A vertical straight:
Bitmap: 1000100010001000
Representation:
1000
1000
1000
1000

Shifting by one bit works fine:
Bitmap: 0100010001000100
Representation:
0100
0100
0100
0100

A horizontal straight:
Bitmap: 1111000000000000
Representation:
1111
0000
0000
0000
0000

Square size needs to be determined before we can decide whether we can shift the bits.
Horizontal straight can be bitshifted by 1 correctly, 
so long as it doesn't wrap around(the square's edge is not at the last bit before shifting)
The null at the end of the char array cannot equal mod box size




HOW TO SHIFT BITS IN A CHAR ARRAY:
One way to handle the bitshifting is to assign the char array to have the trailing 0's at declaration/initialization.
EX: 0000000000000000000000000011011
ptr --------------------------^
Then have a pointer to the first 1
If we need to bitshift it, we can decrement the pointer by 1
EX: ptr-=1;a


We can determine the size of the string by taking size of square ^ 2 and adding trailing zeros except for the bitmap then move the pointer.
need to call strnew with the size^2 each time. 



HOW TO CHECK IF THE STRING HAS CONFLICTS:
//This is for sizes greater than 8 because char arrays
int fit(char *bitmap_str, char *square_str, int size)
{
	int i;
	int flag;

	i = 0;
	flag = 0
	while (bitmap_str[i])
	{
		if (bitmap_str[i]=='1' && (square_str[i+size]=='1' || square_str[i-size]=='1' || square_str[i+1]=='1' || square_str[i-1]=='1'))
			flag = 1;//it is in contact with the square's pieces
		if (square_str[i] == '1' && bitmap_str[i] == '1')
			return 0;//conflict
		i++;
	}
	if (flag)
		return 1;
	return 0;

}

int fit_bitmap(unsigned long long bitmap, unsigned long long potential_solution)
{
	//for the first try into an empty square, the tetrimino will obviously not be in contact with any others.
	//to determine contact use bitshifting by size xors
	if (bitmap ^ potential_solution)//this solution fits
	{
		if(find_last_one(bitmap) % size == 0 || find_first_one(bitmap) + get_width(bitmap) % size == 0) //first or last are at the end/edge
		{
//			IF THIS CONDITION IS TRUE THEN THE TETRIMINO WAS POSITIONED ALONG THE RIGHT EDGE OF THE SQUARE
//			check left and above and below for contact/collisions
			if (((bitmap << 1) ^ potential_solution) || ((bitmap >> size) ^ potential_solution) || ((bitmap << size) ^ potential_solution))
				return 1;
		}
		if(find_last_one(bitmap) -  get_width(bitmap) % size == 1 || find_first_one(bitmap % size == 1))//something like this 
		{
//			IF THIS CONDITION IS TRUE THEN THE TETRIMINO WAS POSITIONED ALONG THE LEFT EDGE OF THE SQUARE
//			check right above below for contact/collisions
			if (((bitmap >> 1) ^ potential_solution) || ((bitmap >> size) ^ potential_solution) || ((bitmap << size) ^ potential_solution))
				return 1;
		}
//	IF NEITHER OF THE ABOVE WERE EXECUTED, THE TETRIMINO CAN SAFETLY BE SHIFTED 1 POSITION.(OR SIZE POSITIONS FOR ABOVE AND BELOW CHECKING)
//	ONCE IT HAS BEEN SHIFTED BY 1 POSITION, DETERMINE WHETHER IT HAS CONTACTED ANOTHER TETRIMINO(COLLIDES) PROVES CONTACT
		if (((bitmap >> 1) ^ potential_solution) || ((bitmap << 1) ^ potential_solution) || ((bitmap >> size) ^ potential_solution) || ((bitmap << size) ^ potential_solution))
			return 1;	
	}
	return 0;
}


//End of function




	//if there was no contact fail return 0;


	//	if (((bitmap >> 1) ^ potential_solution) || ((bitmap << 1) ^ potential_solution) || ((bitmap >> size) ^ potential_solution) || ((bitmap << size) ^ potential_solution))
	//	it will be shifting outside of the square
	else
		{
			shift by 1 to check the next 1 and shift left by 1 to check previous
		}
	
			return 1;//to determine if it is contacting the potential_solution
	}
	return 0;
}

unsigned long long shift_bits(unsigned long long bitmap)
{
	return (bitmap >> 1);//shifts bits right.
}

If (find_last_one(bitmap) % size ==0 || find_first_one(bitmap) + get_width(bitmap) % size == 0) //might be off by one depending on whether they represent the edges or indices
    bitshift by the width
	else
		    bitshift by 1
			^ wont work for normal T's



We might still be able to use an array of structs, just has to be of size 26 and assigned 



Iterating through a size k box check if the bitmap fits
Which will show the size of the box


Notes from video:
Find partial solutions that can be extendible
If it isn't a partial solution remove the element

It would be wise to alter the fit function only to bitshift by amounts that are offby 1 for the previous tetriminoe's last bit so that they're contacting.





Thoughts after sleeping:

When we pass the bitmap to the fit function it won't know the size and it won't be able to bitshift correctly with only 16 bits even 64 isn't enough.
We need to pass in the bitmaps as an array.

Besides that, the fit function needs to know if  tetriminoes are in contact which cannot easily be done without the array structure.



how can we represent moving(bit shifting) after a piece has failed in solve?

Ideally the array of potential solutions only holds size

We should never have to account for shapes greater than 64bits by 64bits right?
64 / 4 = 16
max tetriminoes in one row is 16 assuming all are 4 blocks across which is worst case

64 bits cannot contain a state of vertical straight because it's 

Maybe start the next bitmap at the last open space so if the leading solutions have 1's filled start the bitmap from the first 0.

8x8
AAAABBBB
CCCCDDDD
EEEEFFFF
GGGGHHHH
IIIIJJJJ
KKKKLLLL
MMMMNNNN
OOOOPPPP

9x9
AAAABBBB.
CCCCDDDD.
EEEEFFFF.
GGGGHHHH.
IIIIJJJJ.
KKKKLLLL.
MMMMNNNN.
OOOOPPPP.
QQQQRRRR.

10x10
AAAABBBB..
CCCCDDDD..
EEEEFFFF..
GGGGHHHH..
IIIIJJJJ..
KKKKLLLL..
MMMMNNNN..
OOOOPPPP..
QQQQRRRR..
SSSSTTTT..

11x11
AAAABBBB...
CCCCDDDD...
EEEEFFFF...
GGGGHHHH...
IIIIJJJJ...
KKKKLLLL...
MMMMNNNN...
OOOOPPPP...
QQQQRRRR...
SSSSTTTT...
UUUUVVVV...

12x12
AAAABBBBCCCC
DDDDEEEEFFFF
GGGGHHHHIIII
JJJJKKKKLLLL
MMMMNNNNOOOO
PPPPQQQQRRRR
SSSSTTTTUUUU
VVVVWWWWXXXX
YYYYZZZZ....
............
............
............

13x13
AAAABBBBCCCC.
DDDDEEEEFFFF.
GGGGHHHHIIII.
JJJJKKKKLLLL.
MMMMNNNNOOOO.
PPPPQQQQRRRR.
SSSSTTTTUUUU.
VVVVWWWWXXXX.
YYYYZZZZ.....
.............
.............
.............




While the size of the square is less than 64 bits by 64 bits we can use an array of unsigned long longs because we know that it only needs to represent
Size 2 - 2x2 = 4
Size 3 - 3x3 = 9
Size 4 - 4x4 = 16
Size 5 - 5x5 = 25
Size 6 - 6x6 = 36
Size 7 - 7x7 = 49
Size 8 - 8x8 = 64

Any square of less than size 8 will work with bitmaps(unsigned long longs). Just XOR and place or bitshift XOR and place

If the square is larger than size 8
We will need to convert to char *s 

For bitshifting you could cast it(the unsigned short bitmap) to an unsigned long long then if it fails  bitshift the long long
	WHICH DIRECTION if you merely cast it it will be set to the right bottom corner which is wrong because it will solve out of order(top leftmost is right)
	During cast, multiply the unsigned short times a power
	from 2^8 to 2^64
	unsigned long long newBitmap = pow(bitmap, 8)//might be an incorrect exponentiation...
	After that at each fail just right shift by 1 adding zeros to the front.







		HORIZONTAL STRAIGHT TETRIMINOES

			   1234567890123456789012345678901234567890123456789012345678901234
solutions[A] = 1111000000000000000000000000000000000000000000000000000000000000
solutions[B] = 0000111100000000000000000000000000000000000000000000000000000000
Solutions[C] = 0000000011110000000000000000000000000000000000000000000000000000
Solutions[D] = 0000000000001111000000000000000000000000000000000000000000000000
Solutions[E] = 0000000000000000111100000000000000000000000000000000000000000000
Solutions[F] = 0000000000000000000011110000000000000000000000000000000000000000
Solutions[G] = 0000000000000000000000001111000000000000000000000000000000000000
Solutions[H] = 0000000000000000000000000000111100000000000000000000000000000000
Solutions[I] = 0000000000000000000000000000000011110000000000000000000000000000
Solutions[J] = 0000000000000000000000000000000000001111000000000000000000000000
Solutions[K] = 0000000000000000000000000000000000000000111100000000000000000000
Solutions[L] = 0000000000000000000000000000000000000000000011110000000000000000
Solutions[M] = 0000000000000000000000000000000000000000000000001111000000000000
Solutions[N] = 0000000000000000000000000000000000000000000000000000111100000000
Solutions[O] = 0000000000000000000000000000000000000000000000000000000011110000
Solutions[P] = 0000000000000000000000000000000000000000000000000000000000001111






As an arbitrary decision we will use the short with the topleft most location as our classifying feature(what classify and getwidth take as parameter)

int getwidth(unsigned short bitmap)
{//should be bit comparisons !(bitmap ^ number) idiot.
	if (bitmap == 52224 || bitmap == 35968 || bitmap == 19520 || bitmap == 17600 || bitmap == 51328 || bitmap == 19584 || bitmap == 35904 || !(bitmap ^ 35008) || bitmap == 50240)
		return 2;//square//left t //right t //normal j // upside down j // rotated z // rotated s // normal l // upside down l
    if (bitmap == 34952)
		        return 1;//vertical straight
    if (bitmap == 61440)
		        return 4;//horizontal straight
    if (bitmap == 58368 || bitmap == 19968 || bitmap == 57856 || bitmap == 36352 || bitmap == 50688 || bitmap == 27648 || bitmap == 11776 || bitmap == 59392)
		        return 3;//normal t // upside down //downward j // upward j // normal z // normal s // upward l // downward l
}




In order to check whether the pieces fit inside the current solution, we need to know the size of the square otherwise shifting won't work.
Find the last on bit last 1 check if it is %size == 0 if it is bitshift by the width of the tetrimino


Things to fix:


fit_bitmap needs to know whether the tetriminoes are in contact

the bitshifting needs to know what type of tetrimino so it can shift by width
	This can be done by finding the first and last 1 and the edge (based on size) the shifting by width if the last 1(i+width) is at % size == 0;

It's not always right to shift by the width from first 1 because upside down t will be off by 1
.A...
AAA..
.....
.....
.....

shifting by 3 yields
....A
...AA
A....
.....

even if you know the size // mod size 5



AAAA
BBBB
....
....

Find last 1 for tetrimino's bitshifting.
Use 

int find_last_one(bitmap)
{
	int count = 0;
	while(!bitmap & 1)
	{
		count++;
		bitmap = bitmap >> 1;	
	}
	return count;
}



Calling find_last_one is useful for knowing how many bits we can shift at max.
If (find_last_one(bitmap) % size ==0 || find_first_one(bitmap) + get_width(bitmap) % size == 0) //might be off by one depending on whether they represent the edges or indices
	bitshift by the width
else
	bitshift by 1
^ wont work for normal T's

........................AAA
.........................A.
.....
.....

Need to account for first bit + width % size == 0
 

						       y i x 
							   for horizontal checks check i -1 i+1
								for vertical checks check i - size   i + size
//wont work if you're looping to the next line with two tetriminoes on opposite sides,



It might be wise to read in 20 byte buffers then place them in an array of shorts by reading until running out of tetriminoes 
then using the size to determine where lines are broken and assume that if you reach the end of a short before the end of the last tetrimino, 
move to the next element in the array.


