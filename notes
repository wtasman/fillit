Overview:
	a valid tetrimino has 4 lines of 4 characters followed by a \n
	....
	..##
	.##.
	....

	That means each tetrimino can be represented in 16 bits 17 with that newline
	but you could read until the newline and then cut ignore don't use the \n
	using unsigned short has 16 bits
	maybe use a full 64 bits and represent 4 different tetriminos

	There are a max of (16 * 26) = 416 bits

	No rotations each one is considered different



Required functions:
	is_valid()
		reads the file in
		checks whether the input string is formatted (only '.', '\n', '#')
		checks whether the input string has 4 blocks all connected
		checks whether multiple tetriminos are separated by empty line
		return 1 or 0 valid or invalid
	count_tetriminos()
		counts the newlines and divides by 5 
		only called after is_valid
		used to find the amount of memory to allocate
	

Build a function that can read 16 digits of . and # into a string

	
	classify()
		read 16 bits and determine the tetrimino
		you could use a short and compare to the valid representation's number
		subfunctions{that check if it can be classified.}

	Ignore transpose, once they've been identified, keep a running total of each type 
	then have a solve function passed in the types as an array and return bruteforced value.
	solve()
		take in a struct with the number of each type 
		use bitwise operations to bruteforce all solutions starting one piece at a time.


Solve is passed the array of structs with the type, bitmap(unnecessary because we know the index is arbitrarily assigned), and the count of that type

TETRIMINOES ARE ORDERED IN THE ORDER THEY APPEAR IN THE FILE
Use recursive backtracking for all bitmaps that intersect 1's or can be &'d 
the square root of 546 is 23.36664289109584522132436978521608550591760031674932084141...
so 24 x 24 square is max? see if you can shrink this to save memory

1x1 impossible
2x2 only possible with a single square tetrimino
All others can be made with combinations of pieces and empty spots

Since it's a square the height 
the largest piece is 4 x 1

We need to start in the top left corner with the very first piece and start to build the backtracking
if it fails, move the first piece to the right by one(so long as it's less than our bitmap size)
	it's possib

It might be more effective to treat the first piece as the center, then after solving them, find the smallest square.
Try them all and place them as compact as possible.
the smallest square the return

AAAA......
..........
..........
..........
..........
..........
..........
..........
..........
..........

The output bitmap needs to be called SOLUTION

use !& to find whether the piece fits because & returns true if both are 1 and false otherwise
!& will return false if they're both 1 and true otherwise

use bitshifting to move the default pieces from the top left to the bottom right adding leading 0's
because there are no two dimensional comparisons of 1d bitmaps. 
we will use the bitshifting to represent the next potential solution path 
call recursively passing the bitmap solution which will bitshift if it fails return nothing
if it fits it becomes a possible solution which can be fed new tetriminoes.


	It might be best to use 8 bit descriptions for solve, because the bitshifting is really odd.
	for instance, it won't work for s or z if the offset 1 gets pushed to the next "line" 
	do lines even exist? is it alright for them to be offset if you account for it in the square finding?



Logical stepthrough of recursive backtracking for bitmap with 5x5 with square and l

Call function with square and l

Step 1
.....
.....
.....
.....

Step 2

AA...
AA...
.....
.....
.....

AAB..
AAB..
.BB..
.....
.....

SOLVED! REACHED END OF LIST OF SHAPES
count the square size 3x3 and return to recursive call

AA.B.
AA.B.
..BB.

SOLVED! REACHED END OF LIST OF SHAPES
count the square size 4x4 and return to recursive call

AA..B
AA..B
...BB
.....
.....

SOLVED! REACHED END OF LIST OF SHAPES
count the square size 5x5 and return to recursive call




solve() should:

Call a checking function that determines whether the piece will fit in the potential solution's bitmap.
If it will fit the recursive function should keep calling itself and move to the next piece
If it doesn't fit the recursive function should fail and backtrack to the previously valid potential solution's bitmap
If it reaches the last of the passed in shapes, pass the solution to the size function
If the size function returns a smaller size than the current solution, return the solution bitmap.


Problems I think we may run into:
Bitshifting the pieces
	- The potential solution bitmap will probably 24x24 the bitshifting will be a variable.
	- Bitshifting straights will work fine, but s's and z's l's square's etc will wrap around
	- This could be solved by ignoring lines and have a function that finds size of square define where the square ends.
	- Since the solve function will return all valid solutions, 
		-- a size function will have to draw lines around the piece's edge(which only works if they're labeled ABCDE)
Wasting time
	- Attempting to add pieces that are really far away seems really stupid, 
		but if you don't account for them the pieces from the end of the order won't be able to be at the center.



READ IN FILE WHICH MUST BE LESS THAN 512 bits
	pass the string to is_valid
	is_valid checks validity and passes the substring(defined as the string with bad characters removed) 
	of each tetrimino to ft_btoi(which will return an unsigned short) then to classify
		classify will return the type of the tetrimino as an index to an array of structures
		is_valid will need to iterate the count at the array of structure's index
	if is_valid breaks return the usage message and exit
	if is_valid reaches the null terminater, pass the struct to solve.
	
	


IS_VALID NEEDS THE FULL INPUT STRING

CLASSIFY NEEDS THE SUBSTRING THAT REPRESENTS A TETRIMINO
	classify returns an index to an array of structs which represents the type and count
which is_valid will then iterate

after is_valid completes reading and parsing pass the array to solve

SOLVE NEEDS THE TYPE OF TETRIMINO & THE NUMBER OF THAT TYPE 
19 different types






TETRIMINO STRUCT//89 different bitmaps of valid tetriminoes
	T STRUCT
		t-types
			a
				a1
					bitmap unsigned short
					count
				a2
				a3
				a4
				a5
			b
				b1
				b2
				b3
				b4
				b5
			c
				c1
				c2
				c3
				c4
				c5
			d
				d1
				d2
				d3
				d4
				d5
			e
				e1
				e2
				e3
				e4
				e5
	
	SQUARE STRUCT
		square-types//9 valid
	STRAIGHT STRUCT
		straight-vertical//4 valid
		straight-horizontal//4 valid
	LJ STRUCT
		l-types//24 valid
		j-typesa//24 valid
	SZ STRUCT
		s-types//12 valid
		z-types//12 valid



Different Tetriminos

Straight 
####
....
....
....

horizontal valid binary representations: 
1111000000000000 - 61440
0000111100000000 - 3840
0000000011110000 - 240
0000000000001111 - 15
move = 4

#...
#...
#...
#...

vertical valid binary representations:
1000100010001000 - 34952
0100010001000100 - 17476
0010001000100010 - 8738
0001000100010001 - 4369
move = 1


Square
##..
##..
....
....

square valid binary representations:
1100110000000000 - 52224
0110011000000000 - 26112
0011001100000000 - 13056
0000110011000000 - 3264
0000011001100000 - 1632
0000001100110000 - 816
0000000011001100 - 204
0000000001100110 - 102
0000000000110011 - 51
move = 2

T
###.
.#..
....
....

1110010000000000 - 58368
0111001000000000 - 29184
0000111001000000 - 3648
0000011100100000 - 1824
0000000011100100 - 228
0000000001110010 - 114
move = 3

#... 
##..
#...
....

1000110010000000 - 35968
0100011001000000 - 17984
0010001100100000 - 8992
0000100011001000 - 2248
0000010001100100 - 1124
0000001000110010 - 562
move = 2

.#..
##..
.#..
....

0100110001000000 - 19520
0010011000100000 - 9760
0001001100010000 - 4880
0000010011000100 - 1220
0000001001100010 - 610
0000000100110001 - 305
move = 2


.#..
###.
....
....

0100111000000000 - 19968
0010011100000000 - 9984
0000010011100000 - 1248
0000001001110000 - 624
0000000001001110 - 78
0000000000100111 - 39
move = 3

J
.#..
.#..
##..
....

0100010011000000 - 17600
0010001001100000 - 8800
0001000100110000 - 4400
0000010001001100 - 1100
0000001000100110 - 550
0000000100010011 - 275
move = 2

###.
..#.
....
....

1110001000000000 - 57856
0111000100000000 - 28928
0000111000100000 - 3616
0000011100010000 - 1808
0000000011100010 - 226
0000000001110001 - 113
move = 3


##..
#...
#...
....

1100100010000000 - 51328
0110010001000000 - 25664
0011001000100000 - 12832
0000110010001000 - 3208
0000011001000100 - 1604
0000001100100010 - 802
move = 2

#...
###.
....
....

1000111000000000 - 36352
0100011100000000 - 18176
0000100011100000 - 2272
0000010001110000 - 1136
0000000010001110 - 142
0000000001000111 - 71
move = 3

Z

##..
.##.
....
....

1100011000000000 - 50688
0110001100000000 - 25344
0000011000110000 - 1584
0000110001100000 - 3168
0000000011000110 - 198
0000000001100011 - 99
move = 3

.#..
##..
#...
....

0100110010000000 - 19584
0010011001000000 - 9792
0001001100100000 - 4896
0000010011001000 - 1224
0000001001100100 - 612
0000000100110010 - 306
move = 2

S

.##.
##..
....
....

0110110000000000 - 27648
0011011000000000 - 13824
0000011011000000 - 1728
0000001101100000 - 864
0000000001101100 - 108
0000000000110110 - 54
move = 3

#...
##..
.#..
....

1000110001000000 - 35904
0100011000100000 - 17952
0010001100010000 - 8976
0000100011000100 - 2244
0000010001100010 - 1122
0000001000110001 - 561
move = 2

L

#...
#...
##..
....

1000100011000000 - 35008
0100010001100000 - 17504
0010001000110000 - 8752
0000100010001100 - 2188
0000010001000110 - 1094
0000001000100011 - 547
move = 2

..#.
###.
....
....

0010111000000000 - 11776
0001011100000000 - 5888
0000001011100000 - 736
0000000101110000 - 368
0000000000101110 - 46
0000000000010111 - 23
move = 3

##..
.#..
.#..
....

1100010001000000 - 50240
0110001000100000 - 25120
0011000100010000 - 12560
0000110001000100 - 3140
0000011000100010 - 1570
0000001100010001 - 785
move = 2

###.
#...
....
....

1110100000000000 - 59392
0111010000000000 - 29696
0000111010000000 - 3712
0000011101000000 - 1856
0000000011101000 - 232
0000000001110100 - 116
move = 3
